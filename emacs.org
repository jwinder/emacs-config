* introduction
** getting started

I prefer to clone this repository as =$HOME/emacs-config= and symlink it to =$HOME/.emacs.d=:
#+BEGIN_SRC sh :tangle no
$ git clone git@github.com:jwinder/emacs-config.git $HOME/emacs-config
$ ln -s $HOME/emacs-config $HOME/.emacs.d
#+END_SRC

Optionally, custom settings can be placed inside of a =private= directory of elisp files, or a =private.org= file of elisp code blocks.
#+BEGIN_SRC sh :tangle no
$ ln -s /custom/path/private $HOME/emacs-config/private # directory containing .el files
$ ln -s /custom/path/private.org $HOME/emacs-config/private.org # file containing elisp blocks
#+END_SRC

Now, start emacs.

** org configs

#+TITLE: jwinder emacs config

#+AUTHOR: jwinder

#+LANGUAGE: en

#+SEQ_TODO: ⚑ ⚐ | ✔

* dependencies
** elpa gpg key fix

This is a fix for http://elpa.gnu.org/packages/gnu-elpa-keyring-update.html. Can this go away in future emacs versions?
#+BEGIN_SRC emacs-lisp
(use-package gnu-elpa-keyring-update)
#+END_SRC

** packages

#+BEGIN_SRC emacs-lisp
(use-package afternoon-theme)

(use-package dash)
(use-package f)
(use-package s
  :config (progn
            (defalias 's-empty? 's-blank?)
            (defalias 's-nonempty? 's-present?)
            (defalias 's-nonempty-or-nil 's-presence)))

(use-package helpful
  :config (progn
            (defalias 'describe-key 'helpful-key)
            (defalias 'describe-function 'helpful-callable)
            (defalias 'describe-variable 'helpful-variable)
            (defalias 'describe-symbol 'helpful-symbol)))

(use-package magit) ;; brings in transient

(use-package browse-at-remote)

(use-package gist)

(use-package expand-region)

(use-package multiple-cursors
  :config (progn
            (defun mc/prompt-for-inclusion-in-whitelist (original-command)
              "Rewrite of `mc/prompt-for-inclusion-in-whitelist' to not ask yes/no for every newly seen command."
              (add-to-list 'mc/cmds-to-run-for-all original-command)
              (mc/save-lists)
              t)))

(use-package smartparens
  :config (progn
            (require 'smartparens-config)
            (smartparens-global-mode t)))

(use-package yasnippet)
(use-package yasnippet-snippets)

(use-package counsel) ;; brings in ivy & swiper
(use-package counsel-projectile)

(use-package wgrep
  :config (setq wgrep-auto-save-buffer t))

(use-package undo-tree
  :config (global-undo-tree-mode))

(use-package dumb-jump
  ;; todo emacs 28.1 -- dumb-jump xref backend and use M-. instead of M-s j
  ;; :config (lambda ()
  ;;           (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
  ;;           (setq xref-show-definitions-function #'xref-show-definitions-completing-read) ;; requires xref 1.1.0 on emacs 28.1
  ;;           )
  )

(use-package editorconfig
  :config (editorconfig-mode 1))

(use-package yaml-mode)

(use-package markdown-mode
  :mode (("\\.md$" . gfm-mode)
         ("\\.markdown$" . gfm-mode)))

(use-package dockerfile-mode)

(use-package scala-mode)
(use-package sbt-mode)

(use-package typescript-mode)

(use-package go-mode
  :config (add-hook 'before-save-hook 'gofmt-before-save))
(use-package ob-go)

(use-package ob-mongo)

(use-package coffee-mode
  :config (setq coffee-tab-width 2))

(use-package terraform-mode
  :mode ("\\.tfstate$" . js-mode))

(use-package protobuf-mode)

(use-package groovy-mode
  :mode ("Jenkinsfile$" . groovy-mode))

(use-package jsonnet-mode
  :mode ("\\.libsonnet\\'" . jsonnet-mode))
#+END_SRC

** helper functions

These are non-interactive library functions useful in other parts of this config
#+BEGIN_SRC emacs-lisp
(require 'dash)
(require 's)
(require 'f)
(require 'vc)

(defconst jw--init-org-file (expand-file-name "emacs.org" user-emacs-directory))
(defconst jw--init-file (expand-file-name "emacs.el" user-emacs-directory))
(defconst jw--init-private-org-file (expand-file-name "private.org" user-emacs-directory))
(defconst jw--init-private-file (expand-file-name "private.el" user-emacs-directory))
(defconst jw--init-private-dir (expand-file-name "private" user-emacs-directory))

(defconst jw--emacs-visual-areas '(nil right-fringe left-fringe right-margin left-margin header-line tab-line tab-bar vertical-line vertical-scroll-bar mode-line menu-bar))

(defun jw--font-name (&optional size)
  (if size (format "Monaco %s" size) "Monaco"))

(defconst jw--default-font-size 14)
(setq jw--current-font-size jw--default-font-size)
(defun jw--get-font-size () jw--current-font-size)

(defun jw--set-font-size (&optional size)
  (let ((s (or size jw--default-font-size)))
    (when (and (numberp s) (>= s 8) (<= s 80))
      (setq jw--current-font-size s)
      (set-face-attribute 'default nil :font (jw--font-name s)))))

(defconst jw--default-transparency-alpha 75)
(setq jw--current-transparency-alpha jw--default-transparency-alpha)
(defun jw--get-transparency-alpha () jw--current-transparency-alpha)

(defun jw--set-transparency-alpha (&optional value)
  (let ((v (or value jw--default-transparency-alpha)))
    (when (and (numberp v) (>= v 0) (<= v 100))
      (setq jw--current-transparency-alpha v)
      (set-frame-parameter (selected-frame) 'alpha v))))

(defun jw--login-shell ()
  (file-name-nondirectory (getenv "SHELL")))

(defun jw--all-minor-modes ()
  (sort minor-mode-list 's-less-p))

(defun jw--all-major-modes ()
  (sort (-distinct (mapcar 'cdr (-filter '(lambda (entry) (and (cdr entry) (atom (cdr entry)))) auto-mode-alist))) 's-less-p))

(defmacro jw--save-current-message (&rest body)
  "Saves `current-message', executes the body, then `message' the saved message to the echo area. Any `message' calls within the body will likely not be seen."
  (declare (indent defun))
  `(let ((msg (current-message)))
     (progn ,@body)
     (message msg)))

(defun jw--file-write (string file &optional append encoding)
  (let ((enc (or encoding 'utf-8)))
    (let ((file-dir (file-name-directory file)))
      (unless (f-exists? file-dir) (make-directory file-dir 'mk-parents)))
    (if append (f-append string enc file) (f-write string enc file))))

(defun jw--make-uuid ()
  (downcase (shell-command-to-string "uuidgen | tr -d '\n'")))

(defun jw--pwd ()
  (file-truename default-directory))

(defun jw--vc-root-dir ()
  (let ((vc-root-dir (ignore-errors (vc-call-backend (vc-responsible-backend (jw--pwd)) 'root (jw--pwd)))))
    (if vc-root-dir (file-truename vc-root-dir) nil)))

(defun jw--git-root-dir ()
  (let ((git-root-dir (ignore-errors (vc-find-root (jw--pwd) ".git"))))
    (if git-root-dir (file-truename git-root-dir) nil)))

(defun jw--git-config-get (key)
  (s-presence (s-trim (shell-command-to-string (format "git config --get %s 2>/dev/null" key)))))

(defun jw--iso-current-time-string (&optional utc)
  (if utc
      (format-time-string "%Y-%m-%dT%TZ" nil t)
    (concat (format-time-string "%Y-%m-%dT%T")
            ((lambda (x) (concat (substring x 0 3) ":" (substring x 3 5))) (format-time-string "%z")))))

(defun jw--current-date-string (&optional utc)
  (if utc
      (format-time-string "%Y-%m-%d" nil t)
    (format-time-string "%Y-%m-%d")))

(defun jw--symbol-name (symbol-or-string)
  (if (symbolp symbol-or-string) (symbol-name symbol-or-string) symbol-or-string))

(defun jw--http-get-request-to-string (url)
  (with-current-buffer (url-retrieve-synchronously url)
    (goto-char url-http-end-of-headers)
    (delete-region (point-min) (point))
    (s-trim (buffer-string))))

(defun jw--global-set-visual-area-key (key command &optional areas)
  (global-set-key (kbd key) command)
  (-each (or areas jw--emacs-visual-areas)
    (lambda (area) (global-set-key (kbd (format "<%s> %s" (jw--symbol-name area) key)) command))))

(defun jw--do-when-process-finishes (process fn)
  "Invoke function `fn' after process `process' finishes or exits. `fn' is a one-arg function providing the finished process."
  (when process
    (set-process-sentinel process
                          `(lambda (proc change)
                             (when (string-match "\\(?:finished\\|exited\\)" change)
                               (funcall ,fn proc))))))

(setq jw--run-cmd-shell "bash")
(setq jw--run-cmd-script-dir "/tmp/emacs-jw-run-cmd/")

(cl-defun jw--run-cmd (command &key process-name before-process-creation after-process-creation after-process-finish tail-output delete-tmp-script)
  "An opinionated wrapper around `make-comint-in-buffer'.

For commands that have already finished, this will clean up the process buffer and re-run the command.
For long running processes, this will always toggle back and forth between the process buffer and the other buffer as long as the process is alive.

`:process-name' can be used to override the automatic naming of the process & buffer (from the `command').
`:before-process-creation' is an optional zero-arg function that is run before the process is started.
`:after-process-creation' is an optional one-arg function (providing the process an arg) that is run after the process is started.
`:after-process-finish' is an optional one-arg function (providing the process as an arg) that is run after the process finishes.
`:tail-output' will direct the cursor to tail the output in the emacs buffer, instead of leaving it at the top of the buffer.
`:delete-tmp-script' will remove the underlying shell script, instead of leaving it in the tmp directory.
"
  (require 'comint)
  (let* ((prepared-cmd (string-trim command))
         (cmd-process-name (or process-name (s-collapse-whitespace (s-left 100 prepared-cmd))))
         (cmd-buffer-name (format "*%s*" cmd-process-name)))
    (if (s-empty? prepared-cmd)
        (message "Empty command! Doing nothing.")
      (if (process-live-p (get-process cmd-process-name))
          (if (string= (buffer-name) cmd-buffer-name) (switch-to-buffer (other-buffer)) (switch-to-buffer cmd-buffer-name))
        (let* ((tmp-script-rel-filename (replace-regexp-in-string "[^a-zA-Z0-9]+" "-" cmd-process-name))
               (tmp-script-abs-filename (concat jw--run-cmd-script-dir tmp-script-rel-filename))
               (tmp-script-sh-executable (or (ignore-errors (executable-find jw--run-cmd-shell))
                                             (executable-find (jw--login-shell))))
               (tmp-script-contents (format "#!%s\n\ncd %s\n\n%s\n\necho" tmp-script-sh-executable (jw--pwd) prepared-cmd)))
          (when (get-buffer cmd-buffer-name) (kill-buffer cmd-buffer-name))
          (jw--file-write tmp-script-contents tmp-script-abs-filename)
          (unless (file-executable-p tmp-script-abs-filename) (chmod tmp-script-abs-filename #o744))
          (let* ((process-buffer (get-buffer-create cmd-buffer-name))
                 (run-cmd (lambda ()
                             (insert prepared-cmd "\n\n")
                             (when before-process-creation (funcall before-process-creation))
                             (apply 'make-comint-in-buffer cmd-process-name process-buffer tmp-script-abs-filename nil nil)
                             (let ((proc (get-buffer-process process-buffer)))
                               (when after-process-creation (funcall after-process-creation proc))
                               (jw--do-when-process-finishes (get-buffer-process process-buffer)
                                                             `(lambda (proc)
                                                                (when ,after-process-finish (funcall ,after-process-finish proc))
                                                                (when ,delete-tmp-script (f-delete ,tmp-script-abs-filename 'force))))))))
            (switch-to-buffer process-buffer)
            (if tail-output (funcall run-cmd) (save-excursion (funcall run-cmd)))))))))

(defun jw--run-cmd-tmux (command tmux-session)
  "Create session `tmux-session' if needed, and send `command' to it."
  (call-process "tmux" nil nil nil "new-session" "-d" "-s" tmux-session) ;; this does nothing if the session already exists
  (call-process "tmux" nil nil nil "send-keys" "-t" tmux-session command "C-m"))

(defun jw--sql-pretty-print (begin end)
  "Formats SQL on region between `begin' and `end' using underlying sql-formatter-cli."
  (if (executable-find "sql-formatter")
      (shell-command-on-region begin end "sql-formatter" nil 'replace)
    (message "Required: https://www.npmjs.com/package/sql-formatter -- npm install -g sql-formatter")))
#+END_SRC

* customization
** env

#+BEGIN_SRC emacs-lisp
(require 'eshell)
(require 'esh-mode)

(defun jw-env-set ()
  (interactive)
  (let* ((cmd (format "%s -l -i -c env" (jw--login-shell)))
         (env-big-str (shell-command-to-string cmd))
         (lines (split-string env-big-str "\n")))
    (dolist (line lines)
      (unless (= 0 (length line))
        (let* ((tokens (split-string line "="))
               (name (car tokens))
               (value (mapconcat 'identity (cdr tokens) "=")))
          (setenv name value)
          (when (string= name "PATH")
            (setq exec-path (split-string value ":"))
            (setq eshell-path-env value))))))
  (setenv "EDITOR" "emacsclient"))

(jw-env-set)
(add-to-list 'eshell-mode-hook 'jw-env-set)

#+END_SRC

** style

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)

(load-theme 'afternoon t)
(set-cursor-color "dark grey")
(set-background-color "black")
(set-face-background 'fringe nil)

(jw--set-font-size)

(set-face-attribute 'mode-line nil :font (jw--font-name jw--default-font-size) :background "#22083397778B" :foreground "#7db5d6" :box '(:style released-button))
(set-face-attribute 'mode-line-inactive nil :background "#263238" :foreground "gray" :box '(:style released-button))
(set-face-attribute 'mode-line-buffer-id nil :foreground "white")
(set-face-attribute 'mode-line-highlight nil :foreground "#7db5d6")
(set-face-attribute 'header-line nil :background "#005858" :foreground "white")

(setq jw-mode-line-format '(" " mode-line-buffer-identification (vc-mode vc-mode) " " mode-line-misc-info))
(setq-default mode-line-format jw-mode-line-format)

(setq frame-title-format nil)

(add-hook 'linum-before-numbering-hook (lambda () (set-face-attribute 'linum nil :foreground "#5683a2" :background nil)))

(when (eq system-type 'darwin)
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (add-to-list 'default-frame-alist '(ns-appearance . dark))
  (setq ns-use-proxy-icon nil))

(setq inhibit-startup-message t
      initial-scratch-message ""
      initial-major-mode 'org-mode)
#+END_SRC

fix for cursor color in clients falling back to the default theme [[http:emacs.stackexchange.com/a/14575][copied from stackoverflow]]
#+BEGIN_SRC emacs-lisp
(require 'frame)

(defun fix-colors-for-emacs-clients (frame)
  (modify-frame-parameters frame (list (cons 'cursor-color "dark grey")))
  (modify-frame-parameters frame (list (cons 'background-color "black"))))

(add-hook 'after-make-frame-functions 'fix-colors-for-emacs-clients)
#+END_SRC

** settings

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file 'noerror)

(setq jw-scratch-file (f-expand "scratch.org" user-emacs-directory))

(setq help-window-select t)

(setq enable-local-variables :all)

(setq vc-follow-symlinks t)

(ansi-color-for-comint-mode-on)

(show-paren-mode t)

(fset 'yes-or-no-p 'y-or-n-p)

(setq history-delete-duplicates t)

(setq create-lockfiles nil)

(setq save-silently t)

(setq suggest-key-bindings nil)

(setq kill-whole-line t)

(global-auto-revert-mode 1)

(setq global-auto-revert-non-file-buffers t
      auto-revert-verbose nil)

(setq-default indent-tabs-mode nil)

(setq tab-width 2)
(setq js-indent-level 2)

(delete-selection-mode t)

(winner-mode t)

(global-subword-mode t)

(put 'dired-find-alternate-file 'disabled nil)

(setq wdired-allow-to-change-permissions 'advanced)

(setq dired-listing-switches "-alh")

(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)

(add-hook 'before-save-hook 'delete-trailing-whitespace)

(add-hook 'next-error-hook 'delete-other-windows)

(setq uniquify-buffer-name-style 'forward)

(setq ring-bell-function 'ignore)

(setq enable-recursive-minibuffers t)

(add-to-list 'auto-mode-alist '("\\.scss$" . css-mode))
(add-to-list 'auto-mode-alist '("Gemfile$" . ruby-mode))
(add-to-list 'auto-mode-alist '("Rakefile$" . ruby-mode))
(add-to-list 'auto-mode-alist '("Vagrantfile$" . ruby-mode))
(add-to-list 'auto-mode-alist '("Berksfile$" . ruby-mode))
(add-to-list 'auto-mode-alist '("\\.irbrc$" . ruby-mode))

(setq ruby-insert-encoding-magic-comment nil)

;; (add-hook 'text-mode-hook 'flyspell-mode) ;; i don't use this

(setq ediff-window-setup-function 'ediff-setup-windows-plain)

(put 'narrow-to-region 'disabled nil)

;; (setq calc-angle-mode 'rad)
(setq calc-angle-mode 'deg)

(setq tramp-default-method "ssh")

;; bug: ccrypt prompt for encryption key does not match password input regexp
;; crypt prompts to match: "Enter encryption key:", "Enter encryption key: (repeat)", and "Enter decryption key:"
(setq comint-password-prompt-regexp (concat comint-password-prompt-regexp "\\|^Enter \\(en\\|de\\)cryption key:.*\\s *\\'"))

(defun save-buffers-kill-terminal--advice--ask-yes-or-no (original-function &rest args)
  (if (yes-or-no-p "Is life too much? ") (apply original-function args) (message "Keep up the good fight!")))
(advice-add 'save-buffers-kill-terminal :around 'save-buffers-kill-terminal--advice--ask-yes-or-no)

(defun shell-command--advice--ignore-message-with-no-output (&rest args)
  (when (and (current-message) (string-match "Shell command succeeded with no output" (current-message))) (message nil)))
(advice-add 'shell-command-on-region :after 'shell-command--advice--ignore-message-with-no-output)

(defun kmacro-end-and-call-macro--advice--ask-for-repeat-number-instead-of-using-prefix-numeric-arg (original-function &rest args)
  (if (car args)
      (let* ((repeat-times-string (read-string "How many times to repeat kmacro? "))
             (repeat-times (string-to-number repeat-times-string)))
        (apply original-function (cons repeat-times (cdr args))))
    (apply original-function args)))
(advice-add 'kmacro-end-and-call-macro :around 'kmacro-end-and-call-macro--advice--ask-for-repeat-number-instead-of-using-prefix-numeric-arg)

(setq user-auto-save-directory (expand-file-name "auto-saves/" user-emacs-directory ))
(unless (file-exists-p user-auto-save-directory) (make-directory user-auto-save-directory)) ;; auto-save won't create directories
(setq auto-save-file-name-transforms `((".*" ,user-auto-save-directory t)))

(setq user-backup-directory (expand-file-name "backups/" user-emacs-directory))
(unless (file-exists-p user-backup-directory) (make-directory user-backup-directory))

(setq version-control t
      vc-make-backup-files t
      kept-new-versions 50
      kept-old-versions 0
      backup-by-copying t ;; deep copy of symlinks
      delete-old-versions t)

(setq backup-directory-alist `(("." . ,user-backup-directory)))

(setq savehist-file (expand-file-name "savehist" user-emacs-directory))
(savehist-mode 1)
(setq history-length 500)
(add-to-list 'savehist-additional-variables 'kill-ring)
(add-to-list 'savehist-additional-variables 'search-ring)
(add-to-list 'savehist-additional-variables 'regexp-search-ring)

(when (eq system-type 'gnu/linux)
  (setq interprogram-paste-function 'x-cut-buffer-or-selection-value
        browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "google-chrome"))

(when (eq system-type 'darwin)
  (setq ns-command-modifier 'meta
        browse-url-browser-function 'browse-url-default-macosx-browser))
#+END_SRC

** functions
*** common

#+BEGIN_SRC emacs-lisp
(require 'url-util)

(defalias 'life-is-too-much 'save-buffers-kill-terminal)
(defalias 'filter-lines 'keep-lines)
(defalias 'filter-out-lines 'flush-lines)
(defalias 'elisp-shell 'ielm)

(defun sudo-su ()
  (interactive)
  (let ((goto (or (buffer-file-name) (jw--pwd))))
    (find-file (format "/sudo:root@localhost:%s" goto))))

(defun font-size-set ()
  (interactive)
  (let* ((current (jw--get-font-size))
         (updated (read-string (format "Font size 8 to 80, default %s, current %s: " jw--default-font-size current) (number-to-string current))))
    (jw--set-font-size (string-to-number updated))))

(defun font-size-default () (interactive) (jw--set-font-size))
(defun font-size-increase () (interactive) (jw--set-font-size (1+ (jw--get-font-size))))
(defun font-size-decrease () (interactive) (jw--set-font-size (1- (jw--get-font-size))))

(defun transparency-alpha-set ()
  (interactive)
   (let* ((current (jw--get-transparency-alpha))
          (updated (read-string (format "Transparency alpha 0 to 100, default %s, current %s: " jw--default-transparency-alpha current) (number-to-string current))))
     (jw--set-transparency-alpha (string-to-number updated))))

(defun transparency-alpha-default () (interactive) (jw--set-transparency-alpha))
(defun transparency-alpha-increase () (interactive) (jw--set-transparency-alpha (1+ (jw--get-transparency-alpha))))
(defun transparency-alpha-decrease () (interactive) (jw--set-transparency-alpha (1- (jw--get-transparency-alpha))))

(defun font-size-transparency-alpha-default ()
  (interactive)
  (font-size-default)
  (transparency-alpha-default))

(defun kill-ring-cleanup-last-kill (&optional in-major-mode)
  "Cleans whitespace and reindents the text in the head of the kill ring as if in the major mode."
  (interactive)
  (with-temp-buffer
    (jw--save-current-message
      (let ((mode (or in-major-mode (completing-read "Major mode to mimic: " (jw--all-major-modes) nil t))))
        (yank)
        (funcall (intern-soft mode))
        (indent-region (point-min) (point-max))
        (whitespace-cleanup)
        (kill-new (buffer-substring (point-min) (point-max)) t)))))

(defun kill-ring-save-region-or-line (arg)
  (interactive "P")
  (let ((cleanup-kill arg))
    (if (region-active-p)
        (kill-ring-save (mark) (point))
      (kill-ring-save (line-beginning-position) (line-end-position)))
    (when cleanup-kill (kill-ring-cleanup-last-kill major-mode))))

(defun kill-region-or-line (arg)
  (interactive "P")
  (let ((cleanup-kill arg))
    (if (region-active-p)
        (kill-region (mark) (point))
      (progn (beginning-of-line) (kill-line)))
    (when cleanup-kill (kill-ring-cleanup-last-kill major-mode))))

(defun kill-save-file-or-buffer-name (arg)
  "Kill ring save the current file name. With prefix arg, save the fully qualified path + file name. If the buffer is not visiting a file, use the buffer name."
  (interactive "P")
  (if buffer-file-name
      (if arg
          (kill-new buffer-file-name)
        (kill-new (f-filename buffer-file-name)))
    (kill-new (buffer-name))))

(defun unique-lines ()
  (interactive)
  (if (region-active-p)
      (delete-duplicate-lines (region-beginning) (region-end))
    (delete-duplicate-lines (point-min) (point-max))))

(defun date (&optional arg)
  "Display current date time.
With single prefix arg (C-u M-x date), display calendar around current date.
With extra prefix arg (C-u C-u M-x date), prompt for year & month for calendar."
  (interactive "P")
  (when arg
    (pcase (prefix-numeric-value arg)
      (16 (calendar arg))
      (_ (calendar))))
  (message (current-time-string)))

(defun iso-datetime (utc)
  (interactive "P")
  (message (jw--iso-current-time-string utc)))

(defun insert-iso-datetime (utc)
  (interactive "P")
  (insert (jw--iso-current-time-string utc)))

(defun insert-date (utc)
  (interactive "P")
  (insert (jw--current-date-string utc)))

(defun weather (&optional arg)
  (interactive "P")
  (let* ((raw-query
          (pcase (prefix-numeric-value arg)
            (16 ":help")
            (4 (read-string "Weather for city/state/country/zip/latlong/:help/etc - curl wttr.in/"))
            (_ "")))
         (query (url-encode-url (s-replace "\s" "+" (s-trim raw-query)))))
    (jw--run-cmd (format "curl http://wttr.in/%s" query))))

(setq cheat-sh-candidates nil)
(defun cheat-sh (&optional arg)
  (interactive "P")
  (let* ((raw-query
          (pcase (prefix-numeric-value arg)
            (16 ":help")
            (4 ":list")
            (_ (let ((candidates (progn (when (not cheat-sh-candidates)
                                          (message "Caching cheat.sh candidates list…")
                                          (setq cheat-sh-candidates (process-lines "curl" "--silent" "http://cheat.sh/:list")))
                                        cheat-sh-candidates))
                     (initial (if (region-active-p) (buffer-substring-no-properties (region-beginning) (region-end)) nil)))
                 (completing-read "curl http://cheat.sh/" candidates nil nil initial)))
            ))
         (query (url-encode-url (s-replace "\s" "+" (s-trim raw-query)))))
    (jw--run-cmd (format "curl http://cheat.sh/%s" query))))

(defun scratch-buffer ()
  "Save the scratch buffer in a file. Use any mode you'd like by customizing `jw-scratch-file` to a separate (fully-qualified) filename & extension."
  (interactive)
  (find-file jw-scratch-file)
  (cd (getenv "HOME"))
  (when (get-buffer "*scratch*") (kill-buffer "*scratch*")))

(defun toggle-scratch-buffer ()
  (interactive)
  (if (s-equals? (buffer-name) (f-filename jw-scratch-file))
      (progn
        (save-buffer)
        (switch-to-buffer (other-buffer)))
    (scratch-buffer)))

(defun uuid ()
  (interactive)
  (insert (jw--make-uuid)))

(defun json-prettify ()
  (interactive)
  (if (region-active-p)
      (json-pretty-print (region-beginning) (region-end))
    (json-pretty-print-buffer)))

(defun sql-prettify ()
  (interactive)
  (if (region-active-p)
      (jw--sql-pretty-print (region-beginning) (region-end))
    (jw--sql-pretty-print (point-min) (point-max))))

(defun cmd (command)
  (interactive "sCommand: ")
  (jw--run-cmd command))

(defun cmd-tmux (command &optional tmux-session)
  (interactive "sCommand: ")
  (let ((ts (or tmux-session "emacs")))
    (jw--run-cmd-tmux command ts)
    (message "Sent to tmux session: %s" ts)))

(defun cmd-dwim (arg &optional command)
  "Shell command dwim.

M-x `cmd-dwim' will run an async shell command in a new buffer.
C-u M-x `cmd-dwim' will run a shell command and print the response in the echo area.
C-u C-u M-x `cmd-dwim' will run a shell command and insert the response in the buffer on the next line.
C-u C-u C-u M-x `cmd-dwim' will send a shell command to the default tmux session using `cmd-tmux'.

Interactively:
 - If a region is selected, the region will be used as the shell command.
 - If the point is on a line beginning with a dollar sign (e.g. \"$ whoami\"), the entire line will be used as the shell command.
 - Otherwise, the shell command is read from prompt."
  (interactive "P")
  (let ((prepared-cmd (or command (if (region-active-p)
                                      (buffer-substring-no-properties (region-beginning) (region-end))
                                    (if (s-starts-with? "$" (s-trim (or (thing-at-point 'line t) "")))
                                        (s-trim-left (s-chop-prefix "$" (s-trim (thing-at-point 'line t))))
                                      (read-shell-command "Command: "))))))
    (pcase (prefix-numeric-value arg)
      (16 (save-excursion (open-line-next) (insert (s-trim (shell-command-to-string prepared-cmd)))))
      (64 (cmd-tmux prepared-cmd))
      (4 (message (string-trim (shell-command-to-string prepared-cmd))))
      (_ (cmd prepared-cmd)))))

(transient-define-prefix cmd-menu ()
  ["Run command"
   ("!" "cmd-dwim          M-!   C-u to echo area / C-u C-u on next line" cmd-dwim)
   ("*" "calculator        M-*" calculator)
   (":" "eval-expression   M-:" eval-expression)
   ("e" "eval-last-sexp    C-x C-e" eval-last-sexp)
   ("d" "eval-defun" eval-defun)
   ("r" "eval-region" eval-region)
   ("b" "eval-buffer" eval-buffer)
   ])

(defun beginning-of-line-or-indentation ()
  (interactive)
  (let ((previous-point (point)))
    (back-to-indentation)
    (if (equal previous-point (point))
        (beginning-of-line))))

(defun indent-region-or-buffer--org-mode (arg)
  "Do not indent the entire buffer, only indent active regions.
   My org files can get pretty big, and I tend to indent certain parts of them manually as I see fit."
  (save-excursion
    (when (region-active-p)
      (indent-region (region-beginning) (region-end)))))

(defun indent-region-or-buffer--default (arg)
  (save-excursion
    (if (region-active-p)
        (indent-region (region-beginning) (region-end))
      (indent-region (point-min) (point-max))))
  (when arg (whitespace-cleanup)))

(defun indent-region-or-buffer (arg)
  (interactive "P")
  (jw--save-current-message
    (if (equal major-mode 'org-mode)
        (indent-region-or-buffer--org-mode arg)
      (indent-region-or-buffer--default arg))))

(defun comment-dwim-dwim (&optional arg)
  "When the region is active, then toggle comments over it.
Otherwise, toggle commenting the current line.
With C-u, then append a comment to the end of the line instead.
With C-u C-u, then kill the comment on the current line."
  (interactive "*P")
  (if (region-active-p)
      (comment-dwim arg)
    (pcase (prefix-numeric-value arg)
      (16 (save-excursion (comment-dwim arg)))
      (4 (comment-dwim nil))
      (_ (comment-or-uncomment-region (line-beginning-position) (line-end-position))))))

(defun open-line-next ()
  (interactive)
  (end-of-line)
  (open-line 1)
  (next-line 1)
  (indent-according-to-mode))

(defun open-line-previous ()
  (interactive)
  (beginning-of-line)
  (open-line 1)
  (indent-according-to-mode))

(defun newline-and-open-line-previous ()
  (interactive)
  (let ((was-at-end-of-line (equal (point) (line-end-position))))
    (newline-and-indent)
    (unless was-at-end-of-line (open-line-previous))))

(defun mode-line-on (&optional local)
  (interactive "P")
  (if local
      (setq-local mode-line-format jw-mode-line-format)
    (setq-default mode-line-format jw-mode-line-format)))

(defun mode-line-off (&optional local)
  (interactive "P")
  (if local
      (setq-local mode-line-format nil)
    (setq-default mode-line-format nil)))

(defun current-prefix-arg-raw (arg)
  (interactive "P")
  (message "%s" arg))

(defun current-prefix-arg-numeric (arg)
  (interactive "P")
  (message "%s" (prefix-numeric-value arg)))

(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

(defun rotate-windows (count)
  "Rotate your windows.
Dedicated windows are left untouched. Giving a negative prefix
argument makes the windows rotate backwards."
  (interactive "p")
  (let* ((non-dedicated-windows (remove-if 'window-dedicated-p (window-list)))
         (num-windows (length non-dedicated-windows))
         (i 0)
         (step (+ num-windows count)))
    (cond ((not (> num-windows 1))
           (message "You can't rotate a single window!"))
          (t
           (dotimes (counter (- num-windows 1))
             (let* ((next-i (% (+ step i) num-windows))

                    (w1 (elt non-dedicated-windows i))
                    (w2 (elt non-dedicated-windows next-i))

                    (b1 (window-buffer w1))
                    (b2 (window-buffer w2))

                    (s1 (window-start w1))
                    (s2 (window-start w2)))
               (set-window-buffer w1 b2)
               (set-window-buffer w2 b1)
               (set-window-start w1 s2)
               (set-window-start w2 s1)
               (setq i next-i)))))))

(defun dired-hide-subdir-dwim (arg)
  (interactive "P")
  (save-excursion (if arg (dired-hide-all) (dired-hide-subdir 1))))

(defun dired-do-kill-line-dwim (arg)
  (interactive "P")
  (when arg (dired-tree-up 0))
  (dired-do-kill-lines 1 ""))

(defun dired-do-kill-tree-dwim ()
  (interactive)
  (dired-do-kill-line-dwim 1))
#+END_SRC

*** emacs

#+BEGIN_SRC emacs-lisp
(defun emacs-config ()
  (interactive)
  (find-file jw--init-org-file))

(defun emacs-private-config ()
  (interactive)
  (find-file jw--init-private-org-file))

(defun emacs-configs-toggle (arg)
  (interactive "P")
  (if arg
      (if (string= (buffer-name) (file-name-nondirectory jw--init-private-org-file))
          (switch-to-buffer (other-buffer))
        (emacs-private-config))
    (if (string= (buffer-name) (file-name-nondirectory jw--init-org-file))
        (switch-to-buffer (other-buffer))
      (emacs-config))))

(defun emacs-reload-config ()
  (interactive)
  (load-file user-init-file))

(defun emacs-archive-packages ()
  (when (f-exists? package-user-dir)
    (let ((archive-dir (format "/tmp/emacs-elpa--%s" (jw--iso-current-time-string))))
      (f-move package-user-dir archive-dir))))

(defun emacs-archive-packages-and-die ()
  (interactive)
  (emacs-archive-packages)
  (life-is-too-much))

(defun emacs-byte-compile-elpa-package-files ()
  (interactive)
  (byte-recompile-directory package-user-dir 0 'force))
#+END_SRC

** key bindings

#+BEGIN_SRC emacs-lisp
(define-prefix-command 'jw-keymap)
(global-set-key (kbd "C-x m") 'jw-keymap)
(global-set-key (kbd "C-c m") 'jw-keymap)

(global-set-key (kbd "M-!") 'cmd-dwim)
(global-set-key (kbd "M-&") 'cmd-dwim)
(define-key jw-keymap (kbd "!") 'cmd-menu)
(define-key jw-keymap (kbd "&") 'cmd-menu)
(define-key jw-keymap (kbd "q") 'emacs-configs-toggle)
(define-key jw-keymap (kbd "d") 'date)
(define-key jw-keymap (kbd "w") 'weather)
(define-key jw-keymap (kbd "i") 'toggle-scratch-buffer)

(global-set-key (kbd "C-z") nil) ;; remove suspend
(global-set-key (kbd "C-x C-z") nil)

(global-set-key (kbd "M-*") 'calculator)
(global-set-key (kbd "C-s") 'isearch-forward-regexp)
(global-set-key (kbd "C-r") 'isearch-backward-regexp)
(global-set-key (kbd "C-M-g") 'goto-line)
(global-set-key (kbd "C-M-9") 'winner-undo)
(global-set-key (kbd "C-M-0") 'winner-redo)
(global-set-key (kbd "C-w") 'kill-region-or-line)
(global-set-key (kbd "M-w") 'kill-ring-save-region-or-line)
(global-set-key (kbd "C-a") 'beginning-of-line-or-indentation)
(global-set-key (kbd "C-o") 'open-line-previous)
(global-set-key (kbd "C-<return>") 'open-line-next)
(global-set-key (kbd "C-j") 'newline-and-open-line-previous)
(global-set-key (kbd "C-<tab>") 'indent-region-or-buffer)
(global-set-key (kbd "C-M-;") 'just-one-space)
(global-set-key (kbd "M-;") 'comment-dwim-dwim)
(global-set-key (kbd "C-=") 'er/expand-region)
(global-set-key (kbd "C-+") 'er/contract-region)
(global-set-key (kbd "C-*") 'mc/mark-all-like-this)
(global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
(global-set-key (kbd "C->") 'mc/mark-next-like-this)
(global-set-key (kbd "C-x r t") 'mc/edit-lines)
(define-key sp-keymap (kbd "M-<backspace>") nil)
(define-key sp-keymap (kbd "C-M-p") nil)
(define-key sp-keymap (kbd "C-M-n") nil)
(define-key dired-mode-map (kbd "C-x C-q") 'wdired-change-to-wdired-mode)
(define-key dired-mode-map (kbd "w") 'wdired-change-to-wdired-mode)
(define-key dired-mode-map (kbd "<tab>") 'dired-hide-subdir-dwim)
(define-key dired-mode-map (kbd "$") 'dired-hide-subdir-dwim)
(define-key dired-mode-map (kbd "k") 'dired-do-kill-line-dwim)
(define-key dired-mode-map (kbd "K") 'dired-do-kill-tree-dwim)
(define-key help-map (kbd "M-n") 'helpful-at-point)
(define-key help-map (kbd "H") 'view-hello-file)
(define-key help-map (kbd "h") 'cheat-sh)

;; todo emacs 28.1 -- remove these and use the default xref keybindings
(global-set-key (kbd "M-s j") 'dumb-jump-go)
(global-set-key (kbd "M-s J") 'dumb-jump-go-other-window)

(define-key ctl-x-5-map (kbd "<return>") 'toggle-frame-maximized)
(define-key ctl-x-5-map (kbd "S-<return>") 'toggle-frame-fullscreen)

(define-key ctl-x-4-map (kbd "2") 'toggle-window-split)
(define-key ctl-x-4-map (kbd "3") 'toggle-window-split)
(define-key ctl-x-4-map (kbd "1") 'rotate-windows)
(define-key ctl-x-4-map (kbd "g") 'font-size-transparency-alpha-default)

(define-key ctl-x-4-map (kbd "<up>") 'font-size-increase)
(define-key ctl-x-4-map (kbd "<down>") 'font-size-decrease)
(define-key ctl-x-4-map (kbd "<right>") 'transparency-alpha-increase)
(define-key ctl-x-4-map (kbd "<left>") 'transparency-alpha-decrease)

(jw--global-set-visual-area-key "<C-wheel-up>" 'font-size-increase)
(jw--global-set-visual-area-key "<C-wheel-down>" 'font-size-decrease)
(jw--global-set-visual-area-key "<C-wheel-right>" 'transparency-alpha-increase)
(jw--global-set-visual-area-key "<C-wheel-left>" 'transparency-alpha-decrease)
#+END_SRC

** eshell

#+BEGIN_SRC emacs-lisp
(defun eshell-dwim (arg)
  "A dwim wrapper for `eshell', except that this function provides ordered cycling through all eshells creating using prefix arguments.
No prefix argument: Create a new eshell or switch to an existing eshell. If multiple eshell buffers exist, then cycle through them in their buffer number order.
Single prefix arg C-u: Create an additional eshell: *eshell*, *eshell*<2>, *eshell*<3>, etc.
Negative prefix arg C--: Similar behavior to no prefix argument, except the cycling behavior is in reverse.
"
  (interactive "P")
  (pcase (prefix-numeric-value arg)
    (4 (eshell--dwim-exec arg nil))
    (-1 (eshell--dwim-exec nil t))
    (_ (eshell--dwim-exec nil nil))))

(defun eshell-kill-eshells (arg)
  "Kill all eshells. If a prefix arg is provided, then leave the original eshell buffer alive."
  (interactive "P")
  (-each (eshell--buffers-list)
    (lambda (buffer)
      (unless (and arg (s-equals? "*eshell*" (buffer-name buffer)))
        (kill-buffer buffer)))))

(define-key jw-keymap (kbd "e") 'eshell-dwim)
(define-key jw-keymap (kbd "E") 'eshell-kill-eshells)

(defun eshell--dwim-exec (prefix-arg cycle-backward)
  (if prefix-arg
      (eshell prefix-arg)
    (eshell--cycle-to-next (eshell--buffer-names-list) cycle-backward)))

(defun eshell--extract-buffer-name-digit (buffer)
  (string-to-number (or (car (s-match "[[:digit:]]+" (buffer-name buffer))) "-1")))

(defun eshell--buffers-list-ordering (b1 b2)
  (< (eshell--extract-buffer-name-digit b1) (eshell--extract-buffer-name-digit b2)))

(defun eshell--buffers-list ()
  (-sort 'eshell--buffers-list-ordering (-filter (lambda (buffer) (eq (buffer-local-value 'major-mode buffer) 'eshell-mode)) (buffer-list))))

(defun eshell--buffer-names-list ()
  (-map (lambda (b) (buffer-name b)) (eshell--buffers-list)))

(defun eshell--cycle-to-next (eshells cycle-backward)
  (if (or (not (eq major-mode 'eshell-mode)) (not eshells))
      (eshell nil) ;; switch to or create the first eshell if we're not in an eshell or if no eshells exist
    (let* ((num-eshells (length eshells))
           (idx (or (-elem-index (buffer-name) eshells) num-eshells))
           (next-idx (mod (if cycle-backward (- idx 1) (+ idx 1)) num-eshells))
           (next-eshell (nth next-idx eshells)))
      (switch-to-buffer next-eshell))))

(require 'em-alias)
(eshell/alias "l" "ls -alh")
(eshell/alias "d" "dired $1")
(eshell/alias "e" "find-file $1")
(eshell/alias "emacs" "find-file $1")
(eshell/alias "vi" "find-file $1")
(eshell/alias "vim" "find-file $1")
(eshell/alias "less" "find-file $1")
(eshell/alias "cat" "find-file $1")
(eshell/alias ":q" "exit")
(eshell/alias ":Q" "exit")

(add-to-list 'eshell-mode-hook (lambda ()
                                 (add-to-list 'eshell-visual-commands "htop")
                                 (add-to-list 'eshell-visual-subcommands '("git" "log" "diff" "show"))
                                 (add-to-list 'eshell-visual-subcommands '("g" "log" "diff" "show"))))

(defun eshell/which--advice--add-login-shell-which-output (eshell/which-function &rest names)
  (eshell-printn "\neshell/which:")
  (apply eshell/which-function names)
  (let* ((login-shell-program (jw--login-shell))
         (raw-result (shell-command-to-string (format "%s -c \"which %s\"" login-shell-program (s-join " " names))))
         (login-shell-which-result (format "\n%s's which:\n%s" login-shell-program raw-result)))
    (eshell-printn login-shell-which-result)))

(advice-add 'eshell/which :around 'eshell/which--advice--add-login-shell-which-output)

#+END_SRC

eshell git prompt
#+BEGIN_SRC emacs-lisp
(defun eshell--last-command-status-prompt-string ()
  (if (= 0 eshell-last-command-status)
      ""
    (propertize (format "-%s-\n" eshell-last-command-status) 'face '(:foreground "red3"))))

(defun eshell--git-prompt-string ()
  (require 'vc)
  (if (jw--git-root-dir)
      ;; vc-git-branches returns (list nil) instead of nil when there is no branch name instead of just nil (i.e. after a git-init)
      (let* ((git-branch-name (or (car (vc-git-branches)) "(in the beginning there was darkness)"))
             (git-is-clean (s-blank? (shell-command-to-string "git status --porcelain")))
             (git-is-clean-marker (if git-is-clean "✔" "✘"))
             (git-is-clean-color (if git-is-clean "green" "red1"))
             (git-branch-name-string (propertize git-branch-name 'face '(:foreground "yellow3")))
             (git-is-clean-string (propertize git-is-clean-marker 'face `(:foreground ,git-is-clean-color))))
        (format "%s %s" git-branch-name-string git-is-clean-string))
    ""))

(defun eshell--prompt-function ()
  (let* ((last-status-string (eshell--last-command-status-prompt-string))
         (dir-string (propertize (abbreviate-file-name (eshell/pwd)) 'face '(:foreground "CornflowerBlue")))
         (git-string (eshell--git-prompt-string))
         (prompt-string (propertize (if (= (user-uid) 0) "#" "»") 'face '(:foreground "red3")))
         (right-pad-string (propertize " " 'face '(:foreground nil)))
         (prompt-string (s-collapse-whitespace (format "%s %s %s %s" dir-string git-string prompt-string right-pad-string))))
    (concat last-status-string prompt-string)))

(setq eshell-prompt-function 'eshell--prompt-function)
(setq eshell-prompt-regexp "^[^#$»\n]* [#$»] ")

#+END_SRC

terminal additions
#+BEGIN_SRC emacs-lisp
(defun eshell/ansi (&rest args)
  (interactive)
  (ansi-term (jw--login-shell))
  (when args
    (insert (s-join " " args))
    (term-send-input)))

(setq ansi-term-kill-on-exit t)

(defun ansi-term-life-is-too-much ()
  (interactive)
  (if (not ansi-term-kill-on-exit)
      (bury-buffer)
    (kill-buffer (current-buffer))))

(defun ansi-term--exit-hook ()
  (let ((ansi-process (get-buffer-process (current-buffer))))
    (jw--do-when-process-finishes ansi-process
                                  (lambda (proc)
                                    (switch-to-buffer (process-buffer proc))
                                    (ansi-term-life-is-too-much)))))

(add-hook 'term-mode-hook 'ansi-term--exit-hook)
#+END_SRC

** yasnippet

#+BEGIN_SRC emacs-lisp
(defun yas-dwim (arg)
  (interactive "P")
  (when arg (end-of-buffer) (newline 2))
  (yas-insert-snippet))

(yas-global-mode 1)

(global-set-key (kbd "M-?") 'yas-dwim)

(setq yas-indent-line nil)

(setq yas-dynamic-snippets-dir (f-expand "snippets-dynamic" user-emacs-directory))
(add-to-list 'yas-snippet-dirs yas-dynamic-snippets-dir)

(defun yas-write-dynamic-snippet (mode shortcut contents)
  (let* ((mode-string (jw--symbol-name mode))
         (shortcut-string (jw--symbol-name shortcut))
         (file-location (f-expand (format "%s/%s" mode-string shortcut-string) yas-dynamic-snippets-dir))
         (file-contents-format-string "# -*- mode: snippet -*-\n# name: %s\n# key: %s\n# --\n%s")
         (file-contents (format file-contents-format-string shortcut-string shortcut-string contents)))
    (jw--file-write file-contents file-location)))
#+END_SRC

** git

#+BEGIN_SRC emacs-lisp
(defalias 'git-browse-at-remote 'browse-at-remote)
(defalias 'github-browse-file 'browse-at-remote)

;; magit works faster with the full path to git instead of just "git". https://magit.vc/manual/magit/MacOS-Performance.html
;; also, use-package magit tries to set this before jw-env-set is called, pointing it to a different git.
(setq magit-git-executable (executable-find "git"))

(setq transient-enable-popup-navigation t)
(setq transient-display-buffer-action '(display-buffer-below-selected))

(setq gist-view-gist t)

(defun gist-dwim (&optional arg)
  "Gist region or buffer, private. With a prefix arg, create a public gist."
  (interactive "P")
  (gist-region-or-buffer (not arg)))

(defun dired-do-gist-dwim (&optional arg)
  "Rewrite of dired-do-gist to default to private gists. With a prefix arg, create public gists."
  (interactive "P")
  (dired-do-gist (not arg)))

(defalias 'gist 'gist-dwim) ;; gist package doesn't create its own gist function.

(defun gist-menu--gist-public () (interactive) (gist-dwim t))
(defun gist-menu--gist-private () (interactive) (gist-dwim))
(defun gist-menu--dired-do-gist-public () (interactive) (dired-do-gist-dwim t))
(defun gist-menu--dired-do-gist-private () (interactive) (dired-do-gist-dwim))

(transient-define-prefix gist-menu ()
  ["Gist"
   ("l" "gist-list"                                      gist-list)
   ("g" "gist-dwim            private"                   gist-menu--gist-private)
   ("G" "gist-dwim            public"                    gist-menu--gist-public)
   ("2" "dired-do-gist-dwim   private   @ in dired"      gist-menu--dired-do-gist-private)
   ("@" "dired-do-gist-dwim   public    C-u @ in dired"  gist-menu--dired-do-gist-public)
   ])

(global-set-key (kbd "M-g") 'magit-status)
(define-key jw-keymap "p" 'gist-menu) ;; p = paste, in case more paste services are added to gist-menu
(define-key dired-mode-map "@" 'dired-do-gist-dwim)
#+END_SRC

** rcirc

#+BEGIN_SRC emacs-lisp
(require 'rcirc)

(defun rcirc-connect-dwim (&optional server port nick user-name full-name startup-channels password encryption)
  "Alternative to `rcirc-connect'.
If the server is not connected, then connect to it.
If no server is provided, then a prompt will ask the user for a server.
If the server is connected, then toggle to it's process buffer.
If the server is connected and a prefix arg is provided, then invoke a quick /msg on the server and toggle back to the other-buffer."
  (interactive)
  (if server
      (let ((existing-sp (get-process server)))
        (if (process-live-p existing-sp)
            (if current-prefix-arg
                (save-window-excursion
                  (switch-to-buffer (process-buffer existing-sp))
                  (call-interactively 'rcirc-cmd-msg))
              (switch-to-buffer (process-buffer existing-sp)))
          (rcirc-connect server port nick user-name full-name startup-channels password encryption)))
    (rcirc t)))

(setq rcirc-buffer-maximum-lines 2000)

(add-to-list 'rcirc-omit-responses "MODE")

(custom-set-faces '(rcirc-my-nick ((t (:foreground "#00ffff"))))
                  '(rcirc-other-nick ((t (:foreground "#90ee90"))))
                  '(rcirc-server ((t (:foreground "#a2b5cd"))))
                  '(rcirc-server-prefix ((t (:foreground "#00bfff"))))
                  '(rcirc-timestamp ((t (:foreground "#7d7d7d"))))
                  '(rcirc-nick-in-message ((t (:foreground "#00ffff"))))
                  '(rcirc-prompt ((t (:foreground "#00bfff"))))
                  '(rcirc-keyword ((t :foreground "#00ffff")))
                  '(rcirc-nick-in-message-full-line ((t ())))
                  '(rcirc-track-nick ((t (:foreground "#00ffff"))))
                  '(rcirc-track-keyword ((t (:foreground "#00ffff")))))

(defun rcirc-hook--initial-config ()
  (jw--save-current-message
    (rcirc-track-minor-mode t)
    (rcirc-omit-mode)
    (cd (getenv "HOME"))))

(add-hook 'rcirc-mode-hook 'rcirc-hook--initial-config)

(defun rcirc-hook--span-window-width ()
  (setq rcirc-fill-column (- (window-width) 2)))

(add-hook 'window-configuration-change-hook 'rcirc-hook--span-window-width)

(defun rcirc-handler-NOTICE--advice--ignore-KEEPALIVE (original-function &rest args)
  (let* ((function-args (nth 2 args))
         (msg (cadr function-args)))
    (unless (string-match "keepalive" msg)
      (apply original-function args))))

(advice-add 'rcirc-handler-NOTICE :around 'rcirc-handler-NOTICE--advice--ignore-KEEPALIVE)
#+END_SRC

** org

#+BEGIN_SRC emacs-lisp
(require 'org)

(unless (boundp 'jw-org-todo-file)
  (setq jw-org-todo-file (f-expand "todo.org" user-emacs-directory)))

(defun jw-todo ()
  (interactive)
  (if (s-equals? (buffer-name) (f-filename jw-org-todo-file))
      (switch-to-buffer (other-buffer))
    (find-file jw-org-todo-file)
    (cd (getenv "HOME"))))

(defun jw-todo-backup (arg)
  (interactive "P")
  (jw--run-cmd "todo-backup"
               :after-process-finish `(lambda (proc)
                                        (when ,(null arg) (kill-buffer (process-buffer proc)))
                                        (message "Command jw-todo-backup finished"))))

(setq jw-org-agenda-pre-hook nil)

(defun jw-org-agenda (arg)
  "Enriched `org-agenda' that runs `jw-org-agenda-pre-hook' before `org-agenda' is opened. `org-agenda-mode-hook' can be used for a post-hook"
  (interactive "P")
  (run-hooks 'jw-org-agenda-pre-hook)
  (org-agenda arg))

(defun jw-org-feed-update-all-or-one (arg)
  "When called with a prefix argument, interactively call `org-feed-update'. Otherwise call `org-feed-update-all'."
  (interactive "P")
  (if arg
      (call-interactively 'org-feed-update)
    (org-feed-update-all)))

(defun jw-org-id (arg)
  "Ensure an org-id exists and copy to kill ring. With prefix arg, force creation of a new org-id."
  (interactive "P")
  (org-id-get-create arg)
  (org-id-copy))

(setq org-use-speed-commands t
      org-enforce-todo-dependencies t
      org-enforce-todo-checkbox-dependencies t
      org-return-follows-link t
      org-hide-leading-stars t
      org-clock-clocked-in-display 'mode-line
      org-refile-targets '((org-agenda-files :maxlevel . 10))
      org-refile-use-outline-path t
      org-refile-allow-creating-parent-nodes '(confirm)
      org-tags-column -100
      org-src-preserve-indentation t
      org-src-tab-acts-natively nil
      org-cycle-open-archived-trees t
      org-hide-block-startup t
      org-ellipsis " …"
      org-fontify-done-headline t
      org-todo-keywords '((sequence "⚑" "⚐" "|" "✔" "✘"))
      org-agenda-todo-list-sublevels nil
      org-startup-with-inline-images t
      org-startup-folded t
      org-confirm-babel-evaluate nil
      org-confirm-shell-link-function nil
      org-confirm-elisp-link-function nil
      org-id-link-to-org-use-id 'create-if-interactive
      org-agenda-window-setup 'only-window)

(setq org-src-window-setup 'current-window)

(defun jw-toggle-org-src-window-setup ()
  (interactive)
  (pcase org-src-window-setup
    (`current-window
     (setq org-src-window-setup 'split-window-below)
     (message "Set org-src-window-setup to split-window-below"))
    (_
     (setq org-src-window-setup 'current-window)
     (message "Set org-src-window-setup to current-window"))
    ))

(add-hook 'org-babel-after-execute-hook 'org-display-inline-images)

(define-key jw-keymap (kbd "o") 'jw-todo)
(define-key jw-keymap (kbd "O") 'jw-todo-backup)
(define-key jw-keymap (kbd "a") 'org-agenda)
(define-key jw-keymap (kbd "A") 'jw-org-agenda)
(define-key jw-keymap (kbd "c") 'org-capture)
(define-key ctl-x-4-map (kbd "'") 'jw-toggle-org-src-window-setup)
(add-hook 'org-mode-hook (lambda ()
                           (local-set-key (kbd "C-c <") 'org-time-stamp)
                           (local-set-key (kbd "C-c .") 'org-time-stamp-inactive)
                           (local-set-key (kbd "C-c C-x g") 'jw-org-feed-update-all-or-one)))

(defun org--color-red-box-state (s) `(,s :background "DarkRed" :foreground white :box (:style released-button)))
(defun org--color-red-state (s) `(,s :foreground "Coral"))
(defun org--color-blue-box-state (s) `(,s :background "DeepSkyBlue4" :foreground white :box (:style released-button)))
(defun org--color-blue-state (s) `(,s :foreground "DeepSkyBlue1"))
(defun org--color-green-box-state (s) `(,s :background "DarkGreen" :foreground white :box (:style released-button)))
(defun org--color-green-state (s) `(,s :foreground "LimeGreen"))

(setq org--todo-todo-boxed-states '("todo" "incoming" "captured" "unread" "question")
      org--todo-todo-states '("⚑")
      org--blocked-todo-boxed-states '("blocked" "halted" "stalled" "paused")
      org--doing-todo-boxed-states '("doing" "going")
      org--doing-todo-states '("⚐")
      org--delegated-todo-boxed-states '("delegated" "assigned" "pr" "waiting" "deploying" "note" "idea")
      org--done-todo-boxed-states '("done" "cancelled" "canceled" "finished" "boom" "read" "answered" "noted")
      org--done-todo-states '("✘" "✔"))

(setq org-todo-keyword-faces
      (append
       (mapcar 'org--color-red-box-state org--todo-todo-boxed-states)
       (mapcar 'org--color-red-box-state (mapcar 'upcase org--todo-todo-boxed-states))

       (mapcar 'org--color-red-box-state org--blocked-todo-boxed-states)
       (mapcar 'org--color-red-box-state (mapcar 'upcase org--blocked-todo-boxed-states))

       (mapcar 'org--color-red-state org--todo-todo-states)

       (mapcar 'org--color-blue-box-state org--doing-todo-boxed-states)
       (mapcar 'org--color-blue-box-state (mapcar 'upcase org--doing-todo-boxed-states))

       (mapcar 'org--color-blue-box-state org--delegated-todo-boxed-states)
       (mapcar 'org--color-blue-box-state (mapcar 'upcase org--delegated-todo-boxed-states))

       (mapcar 'org--color-blue-state org--doing-todo-states)

       (mapcar 'org--color-green-box-state org--done-todo-boxed-states)
       (mapcar 'org--color-green-box-state (mapcar 'upcase org--done-todo-boxed-states))

       (mapcar 'org--color-green-state org--done-todo-states)
       ))

(custom-set-faces '(org-link ((t (:underline nil))))
                  '(org-date ((t (:underline nil))))
                  '(org-hide ((t (:foreground "black" :background "black"))))
                  '(org-headline-done ((t (:inherit shadow)))))

(delete '("+" (:strike-through t)) org-emphasis-alist)
(add-to-list 'org-emphasis-alist '("+" (:strike-through t :inherit shadow)))
#+END_SRC

org-babel languages & automatic yasnippet creation
#+BEGIN_SRC emacs-lisp
(defun org-babel-src-yasnippet (ob-lang &optional ob-src-header-override)
  (let* ((yas-src-shortcut (concat "src-" (jw--symbol-name ob-lang)))
         (ob-src-string (format "#+BEGIN_SRC %s\n$0\n#+END_SRC" (jw--symbol-name (or ob-src-header-override ob-lang)))))
    (yas-write-dynamic-snippet 'org-mode yas-src-shortcut ob-src-string)))

(defun org-babel-support-langs (langs)
  (org-babel-do-load-languages 'org-babel-load-languages (-map (lambda (lang) `(,lang . t)) langs))
  (-each langs (lambda (lang) (org-babel-src-yasnippet lang))))

(org-babel-support-langs
 (list 'awk 'emacs-lisp 'lisp 'eshell 'shell 'calc
       'C 'java 'js 'latex 'makefile 'org 'perl 'python 'R 'ruby 'scheme 'sql 'go 'mongo))

(add-to-list 'org-src-lang-modes '("elisp" . emacs-lisp))
(org-babel-src-yasnippet 'elisp 'emacs-lisp)

;; org-babel-execute:bash already exists and there is no ob-bash file, only need the yasnippet
(org-babel-src-yasnippet 'bash)

;; yasnippets for modes that don't need an org-babel-execute function
(org-babel-src-yasnippet 'markdown)
(org-babel-src-yasnippet 'gfm)
(org-babel-src-yasnippet 'conf)
(org-babel-src-yasnippet 'text)
(org-babel-src-yasnippet 'yaml)
(org-babel-src-yasnippet 'json 'js)
(org-babel-src-yasnippet 'javascript 'js)
(org-babel-src-yasnippet 'html)
(org-babel-src-yasnippet 'xml)

(setq org-babel-default-header-args:sh '((:results . "output"))
      org-babel-default-header-args:shell '((:results . "output"))
      org-babel-default-header-args:bash '((:results . "output"))
      org-babel-default-header-args:js '((:results . "output")) ;; doesn't work with "value" for some reason, it just prints "undefined"
      org-babel-default-header-args:python '((:results . "output")) ;; doesn't work with "value" for some reason, it just prints "None"
      org-babel-default-header-args:ruby '((:results . "output"))
      )
#+END_SRC

support =cmd= function in org-babel and =cmd= org link
#+BEGIN_SRC emacs-lisp
(defconst org-babel-header-args:cmd '((bg . :any) (tmux . :any)))

;; warning: cmd does not work with the :async header since ob-cmd is never provided (which org-babel-do-load-languages requires)
(defun org-babel-execute:cmd (body params)
  (let* ((bg-option (assoc :bg params))
         (in-bg (and bg-option (not (string= (cdr bg-option) "no"))))
         (tmux-option (assoc :tmux params))
         (tmux-session (or (cdr tmux-option) "emacs")))
    (if tmux-option
        (progn (cmd-tmux body tmux-session) (format "Sent to tmux session: %s" tmux-session))
      (progn
        (cmd body)
        (when in-bg (switch-to-buffer (other-buffer)))
        "Running command"))))

(add-to-list 'org-src-lang-modes '("cmd" . sh))

(define-derived-mode cmd-mode sh-mode "cmd")

(setq org-babel-default-header-args:cmd '((:results . "silent")))

(org-babel-src-yasnippet 'cmd)
(org-babel-src-yasnippet 'tmux "cmd :tmux")

(add-to-list 'org-link-parameters '("cmd" :follow (lambda (ref) (cmd ref))))
(add-to-list 'org-link-parameters '("cmd+tmux" :follow (lambda (ref) (cmd-tmux ref))))
#+END_SRC

support =gist= and =gist+raw= org links
#+BEGIN_SRC emacs-lisp
(defun org-gist-link-follow (ref &optional raw)
  (let ((url-segment (if (s-contains? "/" ref) ref
                       (concat (or (jw--git-config-get "github.user") (jw--git-config-get "user.name")) "/" ref)))
        (raw-segment (if raw "raw" "")))
    (browse-url (format "https://gist.github.com/%s/%s" url-segment raw-segment))))

(add-to-list 'org-link-parameters '("gist" :follow (lambda (ref) (org-gist-link-follow ref))))
(add-to-list 'org-link-parameters '("gist+raw" :follow (lambda (ref) (org-gist-link-follow ref 'raw))))
#+END_SRC

hacky way of using org tables for markdown tables [[http://stackoverflow.com/questions/14275122/editing-markdown-pipe-tables-in-emacs/26297700#26297700][copied from stackoverflow]]
#+BEGIN_SRC emacs-lisp
(require 'org-table)

(defun markdown-cleanup-org-tables ()
  (interactive)
  (when (or (eq major-mode 'markdown-mode) (eq major-mode 'gfm-mode))
    (save-excursion
      (goto-char (point-min))
      (while (search-forward "-+-" nil t) (replace-match "-|-")))))

(add-hook 'markdown-mode-hook 'turn-on-orgtbl)
(advice-add 'org-table-align :after 'markdown-cleanup-org-tables)

(defalias 'markdown-table-create 'org-table-create)
(defalias 'markdown-table-insert-column 'org-table-insert-column)
(defalias 'markdown-table-delete-column 'org-table-delete-column)
(defalias 'markdown-table-insert-row 'org-table-insert-row)
(defalias 'markdown-table-delete-row 'org-table-delete-row)

#+END_SRC

** scala

#+BEGIN_SRC emacs-lisp
(defun jw-sbt ()
  (interactive)
  (if (eq major-mode 'sbt-mode)
      (switch-to-buffer (other-buffer))
    (with-temp-buffer
      (if (sbt:find-root)
          (sbt-start)
        (call-interactively 'jw-sbt-run-or-create-new)))))

(defun jw-sbt-run-or-create-new (dir)
  (interactive "DSBT run or create new project in: ")
  (when (not (f-exists? dir)) (make-directory dir 'make-parents))
  (let ((default-directory dir))
    (with-temp-buffer
      (if (sbt:find-root)
          (sbt-start)
        (cmd "sbt-new")))))

(defun sbt-compile (test-compile)
  (interactive "P")
  (if test-compile
      (sbt-command "test:compile")
    (sbt-command "compile")))

(defun sbt-current-tests-in-buffer ()
  (save-excursion
    (let* ((pkg-name-components)
           (test-names))
      (goto-char (point-min))
      (while (re-search-forward "package " nil t)
        (push (buffer-substring-no-properties (point) (point-at-eol)) pkg-name-components))
      (goto-char (point-min))
      (while (re-search-forward "\\(object\\|class\\) " nil t)
        (push (buffer-substring-no-properties (point) (progn (re-search-forward " ") (forward-char -1) (point)))
              test-names))
      (let* ((full-pkg-name (string-join (reverse pkg-name-components) "."))
             (full-test-names (mapcar #'(lambda (test-name) (string-join (list full-pkg-name "." test-name))) test-names))
             (full-test-names-str (string-join full-test-names " ")))
        full-test-names-str))))

(defun sbt-test (arg)
  (interactive "P")
  (pcase (prefix-numeric-value arg)
    (4 (sbt-command (concat "testOnly " (sbt-current-tests-in-buffer) " -- ex zzz")))
    (16 (sbt-command "test"))
    (_ (sbt-command (concat "testOnly " (sbt-current-tests-in-buffer))))))

(defun sbt:command--advice--message-command (original-function &rest args)
  (message "sbt %s" (car args))
  (apply original-function args))
(advice-add 'sbt:command :around 'sbt:command--advice--message-command) ;; sbt-command delegates to sbt:command

(add-to-list 'sbt:program-options "-no-colors") ;; remove a lot of extra spacing with new sbt prompt changes

(setq sbt-keymap (make-sparse-keymap))
(fset 'sbt-command-prefix sbt-keymap)

(global-set-key (kbd "C-c s") 'sbt-command-prefix)
(define-key sbt-keymap (kbd "s") 'jw-sbt)
(define-key sbt-keymap (kbd "c") 'sbt-compile)
(define-key sbt-keymap (kbd "o") 'sbt-test)
(define-key sbt-keymap (kbd "l") 'sbt-run-previous-command)

(add-to-list 'auto-mode-alist '("\\.scala$" . scala-mode))
(add-to-list 'auto-mode-alist '("\\.sbt$" . scala-mode))

(setq scala-indent:align-forms t
      scala-indent:align-parameters t)
#+END_SRC

support ammonite repl in org babel, requires `amm` command, or ammonite-repl
#+BEGIN_SRC emacs-lisp
(require 'org)
(require 'ob)

(defun org-babel-execute:ammonite (body params)
  (jw--file-write body "/tmp/ob-ammonite-input.scala")
  (shell-command-to-string "amm --silent /tmp/ob-ammonite-input.scala"))

(add-to-list 'org-src-lang-modes '("ammonite" . scala))

(org-babel-src-yasnippet 'ammonite)
(org-babel-src-yasnippet 'scala 'ammonite) ;; default ob-scala requires brew scala & ensime, which I don't use.
#+END_SRC

** javascript

#+BEGIN_SRC emacs-lisp
(defun jw-js-find-project-root ()
  (let ((project-root (locate-dominating-file (jw--pwd) "package.json")))
    (if project-root (file-truename project-root) nil)))

(defun jw-js-execute (&optional cmd-start)
  "Executes a command in the js project root, looking for package.json or a version control root. Otherwise, uses the pwd."
  (interactive)
  (let ((default-directory (or (jw-js-find-project-root) (jw--vc-root-dir) (jw--pwd))))
    (jw--run-cmd (read-shell-command (format "Run in %s: " default-directory) (if cmd-start (concat (s-trim cmd-start) " ") ""))
                 :tail-output t)))

(defun jw-js-node () (interactive) (jw-js-execute "node"))
(defun jw-js-npm () (interactive) (jw-js-execute "npm"))
(defun jw-js-yarn () (interactive) (jw-js-execute "yarn"))
(defun jw-js-binci () (interactive) (jw-js-execute "binci"))

(setq jw-js-keymap (make-sparse-keymap))
(fset 'jw-js-command-prefix jw-js-keymap)

(global-set-key (kbd "C-c n") 'jw-js-command-prefix) ;; n = node
(define-key jw-js-keymap (kbd "n") 'jw-js-node)
(define-key jw-js-keymap (kbd "m") 'jw-js-npm)
(define-key jw-js-keymap (kbd "y") 'jw-js-yarn)
(define-key jw-js-keymap (kbd "i") 'jw-js-binci)
#+END_SRC

** ivy counsel

#+BEGIN_SRC emacs-lisp
(ivy-mode 1)

(setq ivy-use-virtual-buffers t
      ivy-count-format "%d/%d "
      ivy-initial-inputs-alist nil
      ivy-use-selectable-prompt t
      ivy-magic-tilde nil
      ivy-re-builders-alist '((t . ivy--regex-ignore-order)))
(setq max-mini-window-height 0.90) ;; fix for https://github.com/abo-abo/swiper/issues/2397

(defun counsel-find-file-dwim ()
  (interactive)
  (if (region-active-p)
      (counsel-find-file (buffer-substring-no-properties (region-beginning) (region-end)))
    (counsel-find-file)))

(defun ivy-dispatching-done-ivy ()
  (interactive)
  (let ((ivy-read-action-function #'ivy-read-action-ivy))
    (ivy-dispatching-done)))

(defun counsel-ps-dwim (arg)
  (interactive "P")
  (if arg (proced) (counsel-list-processes)))

(defun counsel-find-file--cmd-dwim-action (file) (let ((default-directory ivy--directory)) (cmd-dwim ivy-current-prefix-arg)))
(defun counsel-find-file--magit-status-action (file) (let ((default-directory ivy--directory)) (magit-status)))
(defun counsel-find-file--eshell-action (file) (let ((default-directory ivy--directory)) (eshell)))
(defun counsel-find-file--dired-action (file) (dired ivy--directory))
(defun counsel-find-file--counsel-ag-action (file) (counsel-ag nil ivy--directory))
(defun counsel-find-file--counsel-rg-action (file) (counsel-rg nil ivy--directory))
(defun counsel-find-file--jw-sbt-action (file) (let ((default-directory ivy--directory)) (jw-sbt)))
(defun counsel-find-file--sbt-compile-action (file) (let ((default-directory ivy--directory)) (sbt-compile ivy-current-prefix-arg)))

(ivy-add-actions
 'counsel-find-file
 '(("!" counsel-find-file--cmd-dwim-action "cmd-dwim in pwd")
   ("g" counsel-find-file--magit-status-action "magit-status in pwd")
   ("ss" counsel-find-file--counsel-ag-action "ag in pwd")
   ("sr" counsel-find-file--counsel-rg-action "rg in pwd")
   ("C-xd" counsel-find-file--dired-action "dired in pwd")
   ("C-cme" counsel-find-file--eshell-action "eshell in pwd")
   ("C-css" counsel-find-file--jw-sbt-action "sbt in pwd")
   ("C-csc" counsel-find-file--sbt-compile-action "sbt compile in pwd")))

(global-set-key (kbd "M-x") 'counsel-M-x)
(define-key ivy-minibuffer-map (kbd "C-o") 'ivy-dispatching-done)
(define-key ivy-minibuffer-map (kbd "M-o") 'ivy-dispatching-done-ivy)
(global-set-key (kbd "C-x C-f") 'counsel-find-file-dwim)
(global-set-key (kbd "C-x F") 'counsel-file-jump)
(global-set-key (kbd "C-x b") 'counsel-switch-buffer)
(global-set-key (kbd "C-x E") 'counsel-kmacro)
(global-set-key (kbd "C-x p") 'counsel-ps-dwim)
(global-set-key (kbd "C-x C-r") 'ivy-resume)
(global-set-key (kbd "M-s o") 'swiper-thing-at-point)
(global-set-key (kbd "C-s") 'swiper)
(global-set-key (kbd "C-r") 'swiper-backward)
(define-key swiper-map (kbd "C-s") 'ivy-next-line)
(define-key swiper-map (kbd "C-r") 'ivy-previous-line)
(global-set-key (kbd "M-s g") 'counsel-grep)
(global-set-key (kbd "M-s s") 'counsel-ag)
(global-set-key (kbd "M-s r") 'counsel-rg)
(global-set-key (kbd "C-M-y") 'counsel-yank-pop)
(define-key counsel-find-file-map (kbd "C-l") 'counsel-up-directory)
(define-key minibuffer-local-map (kbd "C-r") 'counsel-minibuffer-history)
(define-key org-mode-map (kbd "C-c C-j") 'counsel-outline) ;; counsel-org-goto
(add-hook 'eshell-mode-hook (lambda () (define-key eshell-mode-map (kbd "M-p") 'counsel-esh-history)))


(define-key help-map (kbd "b") 'counsel-descbinds)
(define-key help-map (kbd "f") 'counsel-describe-function)
(define-key help-map (kbd "v") 'counsel-describe-variable)
(define-key help-map (kbd "S") 'counsel-info-lookup-symbol)
(define-key help-map (kbd "a") 'counsel-apropos)
#+END_SRC

** projectile

#+BEGIN_SRC emacs-lisp
(setq projectile-completion-system 'ivy)
(counsel-projectile-mode)

(global-set-key (kbd "C-c p") 'projectile-command-map)

(defun counsel-projectile-switch-project--cmd-dwim-action (project)
  (let ((projectile-switch-project-action (lambda () (cmd-dwim ivy-current-prefix-arg))))
    (counsel-projectile-switch-project-by-name project)))

(defun counsel-projectile-switch-project--jw-sbt-action (project)
  (let ((projectile-switch-project-action 'jw-sbt))
    (counsel-projectile-switch-project-by-name project)))

(defun counsel-projectile-switch-project--sbt-compile-action (project)
  (let ((projectile-switch-project-action (lambda () (sbt-compile ivy-current-prefix-arg))))
    (counsel-projectile-switch-project-by-name project)))

(defun counsel-projectile-switch-project--jw-js-node-action (project)
  (let ((projectile-switch-project-action 'jw-js-node))
    (counsel-projectile-switch-project-by-name project)))

(defun counsel-projectile-switch-project--jw-js-npm-action (project)
  (let ((projectile-switch-project-action 'jw-js-npm))
    (counsel-projectile-switch-project-by-name project)))

(defun counsel-projectile-switch-project--jw-js-yarn-action (project)
  (let ((projectile-switch-project-action 'jw-js-yarn))
    (counsel-projectile-switch-project-by-name project)))

(defun counsel-projectile-switch-project--jw-js-binci-action (project)
  (let ((projectile-switch-project-action 'jw-js-binci))
    (counsel-projectile-switch-project-by-name project)))

(ivy-add-actions
 'counsel-projectile-switch-project
 '(("!" counsel-projectile-switch-project--cmd-dwim-action "cmd-dwim in project root")
   ("g" counsel-projectile-switch-project-action-vc "open project in vc-dir / magit / monky")
   ("C-xd" counsel-projectile-switch-project-action-dired "open project in dired")
   ("C-cme" counsel-projectile-switch-project-action-run-eshell "invoke eshell from project root")
   ("C-css" counsel-projectile-switch-project--jw-sbt-action "sbt")
   ("C-csc" counsel-projectile-switch-project--sbt-compile-action "sbt compile")
   ("C-cnn" counsel-projectile-switch-project--jw-js-node-action "js node")
   ("C-cnm" counsel-projectile-switch-project--jw-js-npm-action "js npm")
   ("C-cny" counsel-projectile-switch-project--jw-js-yarn-action "js yarn")
   ("C-cni" counsel-projectile-switch-project--jw-js-binci-action "js binci")
   ))

(defalias 'projectile-empty-garbage 'projectile-cleanup-known-projects)
(defalias 'projectile-purge-everything 'projectile-clear-known-projects)

(defun projectile-clear-known-projects--advice--ask-y-or-n (original-function)
  (if (yes-or-no-p "This will REMOVE ALL projects from projectile. Are you sure?")
      (apply original-function)
    (message "Did NOT clear the projectile projects.")))

(advice-add 'projectile-clear-known-projects :around 'projectile-clear-known-projects--advice--ask-y-or-n)
#+END_SRC

* private

load the =private= directory and the =private.org= file if they exist
#+BEGIN_SRC emacs-lisp
(when (file-exists-p jw--init-private-dir)
  (add-to-list 'load-path jw--init-private-dir)
  (mapcar 'load-file (directory-files jw--init-private-dir t "\.el$")))

(when (file-exists-p jw--init-private-org-file)
  (org-babel-load-file jw--init-private-org-file))
#+END_SRC

* finally

#+BEGIN_SRC emacs-lisp
(yas-reload-all)
(scratch-buffer)
(font-size-transparency-alpha-default)
(cd (getenv "HOME"))
(toggle-frame-maximized)
(mode-line-off)
(unless (server-running-p) (server-start))
#+END_SRC
